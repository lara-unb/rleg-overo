\hypertarget{gdatalogger_8c}{
\section{gdatalogger/gdatalogger.c File Reference}
\label{gdatalogger_8c}\index{gdatalogger/gdatalogger.c@{gdatalogger/gdatalogger.c}}
}
{\ttfamily \#include $<$math.h$>$}\par
{\ttfamily \#include $<$stdio.h$>$}\par
{\ttfamily \#include $<$stdlib.h$>$}\par
{\ttfamily \#include $<$string.h$>$}\par
{\ttfamily \#include $<$sys/types.h$>$}\par
{\ttfamily \#include $<$unistd.h$>$}\par
{\ttfamily \#include $<$sys/mman.h$>$}\par
{\ttfamily \#include $<$fcntl.h$>$}\par
{\ttfamily \#include $<$sys/stat.h$>$}\par
{\ttfamily \#include $<$errno.h$>$}\par
{\ttfamily \#include \char`\"{}gqueue.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}gmatlabdatafile.h\char`\"{}}\par
{\ttfamily \#include \char`\"{}gdatalogger.h\char`\"{}}\par
Include dependency graph for gdatalogger.c:\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{gdatalogger_8c_ab5eeb22d60836d57bae0dde821337045}{gDataLogger\_\-Init} (\hyperlink{structGDATALOGGER}{PGDATALOGGER} pgDataLogger, char $\ast$filename, char $\ast$dirname)
\item 
int \hyperlink{gdatalogger_8c_a3f8f2b3c3f5edc72c3a1887965a544c1}{gDataLogger\_\-DeclareVariable} (\hyperlink{structGDATALOGGER}{PGDATALOGGER} pgDataLogger, char $\ast$varname, char $\ast$varunit, int nrows, int ncols, int queuesize)
\item 
int \hyperlink{gdatalogger_8c_a32674e7c2afa8b78e99a0070cf4bcaf9}{gDataLogger\_\-InsertVariable} (\hyperlink{structGDATALOGGER}{PGDATALOGGER} pgDataLogger, char $\ast$varname, double $\ast$varvalue)
\item 
int \hyperlink{gdatalogger_8c_a05dc8ce832b941280d7de26057992640}{gDataLogger\_\-MatfileUpdate} (\hyperlink{structGDATALOGGER}{PGDATALOGGER} pgDataLogger)
\item 
int \hyperlink{gdatalogger_8c_afa42a993493cf98d32da11e4279816f7}{gDataLogger\_\-IPCUpdate} (\hyperlink{structGDATALOGGER}{PGDATALOGGER} pgDataLogger)
\item 
int \hyperlink{gdatalogger_8c_a555a2628f1bfa33692e5f51961d287a5}{gDataLogger\_\-IPC\_\-RetrieveVariable} (char $\ast$varname, char $\ast$varunit, double $\ast$pbuffer, int $\ast$bufferlen)
\item 
int \hyperlink{gdatalogger_8c_a0ac95f84c6ee484c4ad0351530f1c468}{gDataLogger\_\-Close} (\hyperlink{structGDATALOGGER}{PGDATALOGGER} pgDataLogger)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{structGDATALOGGERIPC__SHM}{GDATALOGGERIPC\_\-SHM} $\ast$ \hyperlink{gdatalogger_8c_af7df326df930ef7f72e0a173e443db7e}{pgDataLoggerIPC\_\-SHM} = NULL
\item 
static int \hyperlink{gdatalogger_8c_ab05e4213b873bbf0185738b7fd8a6e4a}{gDataLoggerIPC\_\-SHM\_\-flagmodeserver} = 1
\item 
static int \hyperlink{gdatalogger_8c_a0400c04ba687b9806fc9543f817388d0}{gDataLoggerIPC\_\-SHM\_\-fd} = 0
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{gdatalogger_8c_a0ac95f84c6ee484c4ad0351530f1c468}{
\index{gdatalogger.c@{gdatalogger.c}!gDataLogger\_\-Close@{gDataLogger\_\-Close}}
\index{gDataLogger\_\-Close@{gDataLogger\_\-Close}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{gDataLogger\_\-Close}]{\setlength{\rightskip}{0pt plus 5cm}int gDataLogger\_\-Close ({\bf PGDATALOGGER} {\em pgDataLogger})}}
\label{gdatalogger_8c_a0ac95f84c6ee484c4ad0351530f1c468}


Definition at line 362 of file gdatalogger.c.



References GDATALOGGERVARIABLE::CircularQueue, GDATALOGGER\_\-IPC\_\-STATEFILE, gDataLogger\_\-MatfileUpdate(), gDataLoggerIPC\_\-SHM\_\-fd, gDataLoggerIPC\_\-SHM\_\-flagmodeserver, gMATLABDataFile\_\-Close(), gMATLABDataFile\_\-SaveVector(), GDATALOGGER::GMatlabDataFileConfig, GDATALOGGERVARIABLE::GMatlabDataFileIndex, GDATALOGGERVARIABLE::HasBeenWritten, GDATALOGGER::m\_\-NumberOfVariables, GDATALOGGERVARIABLE::Nc, GDATALOGGERVARIABLE::Nr, TRUE, GDATALOGGERVARIABLE::VariableName, GDATALOGGER::Variables, and GDATALOGGERVARIABLE::VariableUnit.



Referenced by datalogger\_\-close().




\begin{DoxyCode}
363 {
364         int nvar,datasize;
365         double v;
366     double *value;
367         char matvarname[70];
368 
369         /* Garante salvar ultimos dados inseridos: */
370         if(pgDataLogger!=NULL){
371                 gDataLogger_MatfileUpdate(pgDataLogger);
372 
373                 /* Se for um unico escalar, trata de forma especial: */
374         for(nvar=0;nvar<pgDataLogger->m_NumberOfVariables;++nvar){
375             if((pgDataLogger->Variables[nvar].Nc == 1)&&(pgDataLogger->Variables[
      nvar].Nr == 1)){
376                     if(pgDataLogger->Variables[nvar].HasBeenWritten == 1){
377                         value = (double *) malloc(sizeof(double));
378                         value[0] = pgDataLogger->Variables[nvar].CircularQueue[0]
      ;
379                         sprintf(matvarname,"%s_%li_%li",pgDataLogger->Variables[n
      var].VariableName, (long int)0, (long int)0);
380                         gMATLABDataFile_SaveVector(&pgDataLogger->
      GMatlabDataFileConfig, matvarname, value, 1);
381                         free(value);
382                         pgDataLogger->Variables[nvar].GMatlabDataFileIndex = 1;
383                     }
384             }
385         }
386 
387                 /* Cria variaveis que indicam o numero de cada variavel salva: */
      
388                 for(nvar=0;nvar<pgDataLogger->m_NumberOfVariables;++nvar){
389                         v = (double)(pgDataLogger->Variables[nvar].
      GMatlabDataFileIndex);
390                         datasize = 1;
391                         sprintf(matvarname,"%s_size",pgDataLogger->Variables[nvar
      ].VariableName);
392                         gMATLABDataFile_SaveVector(&pgDataLogger->
      GMatlabDataFileConfig, matvarname, &v, datasize);
393                 }
394 
395                 /* Salva o numero de linhas: */
396                 for(nvar=0;nvar<pgDataLogger->m_NumberOfVariables;++nvar){
397                         v = (double)(pgDataLogger->Variables[nvar].Nr);
398                         datasize = 1;
399                         sprintf(matvarname,"%s_nr",pgDataLogger->Variables[nvar].
      VariableName);
400                         gMATLABDataFile_SaveVector(&pgDataLogger->
      GMatlabDataFileConfig, matvarname, &v, datasize);
401                 }
402 
403                 /* Salva o numero de colunas: */
404                 for(nvar=0;nvar<pgDataLogger->m_NumberOfVariables;++nvar){
405                         v = (double)(pgDataLogger->Variables[nvar].Nc);
406                         datasize = 1;
407                         sprintf(matvarname,"%s_nc",pgDataLogger->Variables[nvar].
      VariableName);
408                         gMATLABDataFile_SaveVector(&pgDataLogger->
      GMatlabDataFileConfig, matvarname, &v, datasize);
409                 }
410 
411                 /* Fecha o arquivo. */
412                 gMATLABDataFile_Close(&pgDataLogger->GMatlabDataFileConfig);
413 
414                 /* Deletar as filas: */
415                 for(nvar=0;nvar<pgDataLogger->m_NumberOfVariables;++nvar){
416                         sprintf(pgDataLogger->Variables[nvar].VariableName," ");
417                         sprintf(pgDataLogger->Variables[nvar].VariableUnit," ");
418                         free(pgDataLogger->Variables[nvar].CircularQueue);
419                         pgDataLogger->Variables[nvar].CircularQueue = NULL;
420                         pgDataLogger->Variables[nvar].GMatlabDataFileIndex = 0;
421                 }
422                 pgDataLogger->m_NumberOfVariables = 0;
423         }
424         
425         /* IPC: */
426 #if DATALOGGER_COMPILE_FOR_XENOMAI
427         if(gDataLoggerIPC_SHM_flagmodeserver){
428                 rt_heap_free(&gDataLoggerIPC_SHM_hd,pgDataLoggerIPC_SHM);
429                 rt_heap_delete(&gDataLoggerIPC_SHM_hd);
430         } else{
431                 rt_heap_unbind(&gDataLoggerIPC_SHM_hd);
432         }
433 #else
434         munmap(pgDataLoggerIPC_SHM, sizeof(GDATALOGGERIPC_SHM));
435         close(gDataLoggerIPC_SHM_fd);
436         shm_unlink(GDATALOGGER_IPC_STATEFILE);
437 #endif
438         
439         return(TRUE);
440 }
\end{DoxyCode}




Here is the call graph for this function:



Here is the caller graph for this function:

\hypertarget{gdatalogger_8c_a3f8f2b3c3f5edc72c3a1887965a544c1}{
\index{gdatalogger.c@{gdatalogger.c}!gDataLogger\_\-DeclareVariable@{gDataLogger\_\-DeclareVariable}}
\index{gDataLogger\_\-DeclareVariable@{gDataLogger\_\-DeclareVariable}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{gDataLogger\_\-DeclareVariable}]{\setlength{\rightskip}{0pt plus 5cm}int gDataLogger\_\-DeclareVariable ({\bf PGDATALOGGER} {\em pgDataLogger}, \/  char $\ast$ {\em varname}, \/  char $\ast$ {\em varunit}, \/  int {\em nrows}, \/  int {\em ncols}, \/  int {\em queuesize})}}
\label{gdatalogger_8c_a3f8f2b3c3f5edc72c3a1887965a544c1}


Definition at line 173 of file gdatalogger.c.



References GDATALOGGERVARIABLE::CircularQueue, GDATALOGGERVARIABLE::CircularQueueControl, FALSE, GDATALOGGER\_\-MAXVARIABLES, GDATALOGGERVARIABLE::GMatlabDataFileIndex, gQUEUE\_\-Init(), GDATALOGGER::m\_\-NumberOfVariables, GDATALOGGERVARIABLE::Nc, GDATALOGGERVARIABLE::Nr, QUEUE\_\-MAXDESTINATIONS, TRUE, GDATALOGGERVARIABLE::VariableName, GDATALOGGER::Variables, and GDATALOGGERVARIABLE::VariableUnit.



Referenced by datalogger\_\-init().




\begin{DoxyCode}
174 {
175         if(pgDataLogger->m_NumberOfVariables>=GDATALOGGER_MAXVARIABLES-1){
176                 return(FALSE);
177         }
178         queuesize = queuesize * nrows * ncols; /* no caso, o tamanho da fila eh c
      alculado em numero de elementos double. */
179         sprintf(pgDataLogger->Variables[pgDataLogger->m_NumberOfVariables].
      VariableName,"%s",varname);
180         sprintf(pgDataLogger->Variables[pgDataLogger->m_NumberOfVariables].
      VariableUnit,"%s",varunit);
181         pgDataLogger->Variables[pgDataLogger->m_NumberOfVariables].CircularQueue 
      = (double *) malloc(queuesize * nrows * ncols * sizeof(double));
182         if(pgDataLogger->Variables[pgDataLogger->m_NumberOfVariables].
      CircularQueue==NULL){
183                 return(FALSE);
184         }
185         pgDataLogger->Variables[pgDataLogger->m_NumberOfVariables].Nr = nrows;
186         pgDataLogger->Variables[pgDataLogger->m_NumberOfVariables].Nc = ncols;
187         gQUEUE_Init(&pgDataLogger->Variables[pgDataLogger->m_NumberOfVariables].
      CircularQueueControl, queuesize, QUEUE_MAXDESTINATIONS);
188         pgDataLogger->Variables[pgDataLogger->m_NumberOfVariables].
      GMatlabDataFileIndex = 0;
189         
190         ++pgDataLogger->m_NumberOfVariables;
191 
192         return(TRUE);
193 }
\end{DoxyCode}




Here is the call graph for this function:



Here is the caller graph for this function:

\hypertarget{gdatalogger_8c_ab5eeb22d60836d57bae0dde821337045}{
\index{gdatalogger.c@{gdatalogger.c}!gDataLogger\_\-Init@{gDataLogger\_\-Init}}
\index{gDataLogger\_\-Init@{gDataLogger\_\-Init}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{gDataLogger\_\-Init}]{\setlength{\rightskip}{0pt plus 5cm}int gDataLogger\_\-Init ({\bf PGDATALOGGER} {\em pgDataLogger}, \/  char $\ast$ {\em filename}, \/  char $\ast$ {\em dirname})}}
\label{gdatalogger_8c_ab5eeb22d60836d57bae0dde821337045}


Definition at line 42 of file gdatalogger.c.



References GDATALOGGERVARIABLE::CircularQueue, FALSE, GDATALOGGERIPC\_\-SHM::Flag, GDATALOGGER\_\-IPC\_\-FLAGIDDLE, GDATALOGGER\_\-IPC\_\-STATEFILE, GDATALOGGER\_\-MAXVARIABLES, gDataLoggerIPC\_\-SHM\_\-fd, gDataLoggerIPC\_\-SHM\_\-flagmodeserver, gMATLABDataFile\_\-OpenWrite(), GDATALOGGER::GMatlabDataFileConfig, GDATALOGGERVARIABLE::GMatlabDataFileIndex, GDATALOGGERVARIABLE::HasBeenWritten, GDATALOGGER::m\_\-NumberOfVariables, GDATALOGGERVARIABLE::Nc, GDATALOGGERVARIABLE::Nr, status, TRUE, GDATALOGGERVARIABLE::VariableName, GDATALOGGER::Variables, and GDATALOGGERVARIABLE::VariableUnit.



Referenced by datalogger\_\-init().




\begin{DoxyCode}
43 {
44         int i;
45         int first = 0;
46 #if DATALOGGER_COMPILE_FOR_XENOMAI
47         int err;
48 #else
49         int status = 0;
50 #endif
51 
52         /* GQueue */
53         if(pgDataLogger!=NULL){
54                 for (i=0;i<GDATALOGGER_MAXVARIABLES;++i){
55                         sprintf(pgDataLogger->Variables[i].VariableName," ");
56                         sprintf(pgDataLogger->Variables[i].VariableUnit," ");
57                         pgDataLogger->Variables[i].CircularQueue = NULL;
58                         pgDataLogger->Variables[i].GMatlabDataFileIndex = 0;
59                         pgDataLogger->Variables[i].Nc = 1;
60                         pgDataLogger->Variables[i].Nr = 1;
61             pgDataLogger->Variables[i].HasBeenWritten = 0;
62                 }
63                 pgDataLogger->m_NumberOfVariables = 0;
64         }
65 
66         /* IPC */
67 #if DATALOGGER_COMPILE_FOR_XENOMAI
68         if(pgDataLogger!=NULL){
69                 /* cria memoria compartilhada */
70                 int heapsize;
71                 if(sizeof(GDATALOGGERIPC_SHM) > ((256*1024))){
72                         heapsize = sizeof(GDATALOGGERIPC_SHM);
73                 }
74                 else{
75                         heapsize = ((256*1024));
76                 }
77                 
78                 if((err=rt_heap_create(&gDataLoggerIPC_SHM_hd,
      GDATALOGGER_IPC_STATEFILE,sizeof(GDATALOGGERIPC_SHM),H_SHARED))!=0){
79                         printf("gDataLogger_Init: Could not create xenomai heap o
      bject (return %i)\n", err);
80                         printf("\n EEXIST = %i",EEXIST);
81                         printf("\n EINVAL = %i",EINVAL);
82                         printf("\n ENOMEM = %i",ENOMEM);
83                         printf("\n EPERM = %i",EPERM);
84                         printf("\n EIDRM = %i",EIDRM);
85                         printf("\n ENOSYS = %i",ENOSYS);
86                         if(err==-EEXIST){
87                                 err=rt_heap_delete(&gDataLoggerIPC_SHM_hd);
88                                 printf("gDataLogger_Init: Deleting xenomai heap o
      bject (return %i)\n", err);
89                         }
90                         return FALSE;
91                 }
92 
93                 if(rt_heap_alloc(&gDataLoggerIPC_SHM_hd,sizeof(
      GDATALOGGERIPC_SHM),TM_NONBLOCK,(void**)&pgDataLoggerIPC_SHM)!=0){
94                         printf("gDataLogger_Init: Could not allocated xenomai hea
      p object. (return %i)\n", err);
95                         return FALSE;
96                 }
97 
98                 first = 1; /* We are the first instance */
99                 gDataLoggerIPC_SHM_flagmodeserver = 1;
100         }
101         else{
102                 /* abre memoria compartilhada */
103                 if((err=rt_heap_bind(&gDataLoggerIPC_SHM_hd,
      GDATALOGGER_IPC_STATEFILE,TM_NONBLOCK))!=0){
104                         /* printf("gDataLogger_Init: Could not create xenomai hea
      p object (return %i)\n", err); */
105 /*                      printf("\n EEXIST = %i",EEXIST);
106                         printf("\n EINVAL = %i",EINVAL);
107                         printf("\n ENOMEM = %i",ENOMEM);
108                         printf("\n EPERM = %i",EPERM);
109                         printf("\n EIDRM = %i",EIDRM);
110                         printf("\n ENOSYS = %i",ENOSYS);*/
111                         return FALSE;
112                 }
113 
114                 if(rt_heap_alloc(&gDataLoggerIPC_SHM_hd,0,TM_NONBLOCK,(void**)&
      pgDataLoggerIPC_SHM)!=0){
115                         printf("gDataLogger_Init: Could not allocated xenomai hea
      p object. (return %i)\n", err);
116                         return FALSE;
117                 }
118 
119                 gDataLoggerIPC_SHM_flagmodeserver = 0;
120         }
121 
122 #else
123         /* Try to open the shm instance with  O_EXCL, this tests if the shm is al
      ready opened by someone else */
124         if((gDataLoggerIPC_SHM_fd = shm_open(GDATALOGGER_IPC_STATEFILE, (O_CREAT 
      | O_RDWR),(S_IREAD | S_IWRITE))) < 0) {
125                 /* Try to open the shm instance normally and share it with existi
      ng clients */
126                 printf("gDataLogger_Init: Could not create shm object. %s\n", str
      error(errno));
127                 return FALSE;
128         }       
129         if(pgDataLogger!=NULL){
130                 gDataLoggerIPC_SHM_flagmodeserver = 1;
131                 first = 1;
132         } else{
133                 gDataLoggerIPC_SHM_flagmodeserver = 0;
134                 first = 0;
135         }
136 /*      if((gDataLoggerIPC_SHM_fd = shm_open(GDATALOGGER_IPC_STATEFILE, (O_CREAT 
      | O_EXCL | O_RDWR),(S_IREAD | S_IWRITE))) > 0 ) {
137 */                first = 1; /* We are the first instance */
138 /*                gDataLoggerIPC_SHM_flagmodeserver = 1;
139         }
140         else if((gDataLoggerIPC_SHM_fd = shm_open(GDATALOGGER_IPC_STATEFILE, (O_C
      REAT | O_RDWR),(S_IREAD | S_IWRITE))) < 0) {
141 */              /* Try to open the shm instance normally and share it with existi
      ng clients */
142 /*              printf("gDataLogger_Init: Could not create shm object. %s\n", str
      error(errno));
143                 return FALSE;
144         } 
145 */      /* Set the size of the SHM to be the size of the struct. */
146         status = ftruncate(gDataLoggerIPC_SHM_fd, sizeof(GDATALOGGERIPC_SHM));
147 
148         /* Connect the conf pointer to set to the shared memory area, with desire
      d permissions */
149         if((pgDataLoggerIPC_SHM =  mmap(0, sizeof(GDATALOGGERIPC_SHM), (PROT_READ
       | PROT_WRITE), MAP_SHARED, gDataLoggerIPC_SHM_fd, 0)) == MAP_FAILED) {
150                 return FALSE;
151         }
152 
153         /* Set permission so all can read/write to shared memory */
154     status = fchmod(gDataLoggerIPC_SHM_fd, (S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWG
      RP|S_IXGRP|S_IROTH|S_IWOTH|S_IXOTH));
155 
156 #endif
157         
158         if(first){
159                 pgDataLoggerIPC_SHM->Flag = GDATALOGGER_IPC_FLAGIDDLE;
160         }
161 
162         /* GMatlabDataFile */
163         if((pgDataLogger!=NULL)&&(filename!=NULL)){
164                 return(gMATLABDataFile_OpenWrite(&pgDataLogger->
      GMatlabDataFileConfig, filename, dirname));
165         }
166         
167         return TRUE;
168 }
\end{DoxyCode}




Here is the call graph for this function:



Here is the caller graph for this function:

\hypertarget{gdatalogger_8c_a32674e7c2afa8b78e99a0070cf4bcaf9}{
\index{gdatalogger.c@{gdatalogger.c}!gDataLogger\_\-InsertVariable@{gDataLogger\_\-InsertVariable}}
\index{gDataLogger\_\-InsertVariable@{gDataLogger\_\-InsertVariable}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{gDataLogger\_\-InsertVariable}]{\setlength{\rightskip}{0pt plus 5cm}int gDataLogger\_\-InsertVariable ({\bf PGDATALOGGER} {\em pgDataLogger}, \/  char $\ast$ {\em varname}, \/  double $\ast$ {\em varvalue})}}
\label{gdatalogger_8c_a32674e7c2afa8b78e99a0070cf4bcaf9}


Definition at line 199 of file gdatalogger.c.



References GDATALOGGERVARIABLE::CircularQueue, GDATALOGGERVARIABLE::CircularQueueControl, FALSE, GQUEUECONTROL::FlagFull, gDataLogger\_\-MatfileUpdate(), gQUEUE\_\-RequestWriteIndex(), GDATALOGGERVARIABLE::HasBeenWritten, GDATALOGGER::m\_\-NumberOfVariables, GDATALOGGERVARIABLE::Nc, GDATALOGGERVARIABLE::Nr, QUEUE\_\-DESTINATION\_\-FILE, TRUE, GDATALOGGERVARIABLE::VariableName, and GDATALOGGER::Variables.



Referenced by datalogger\_\-init(), datalogger\_\-set\_\-Ts(), and datalogger\_\-update().




\begin{DoxyCode}
200 {
201         int queueindex,varindex,n;
202         long int nr,nc;
203         int FlagQueueFull;
204         
205         /* Procura pela variavel */
206         varindex = -1;
207         for(n=0;n<pgDataLogger->m_NumberOfVariables;++n){
208                 if(strcmp(varname,pgDataLogger->Variables[n].VariableName)==0){
209                         varindex = n;
210                         break;
211                 }
212         }
213         if(varindex<0){
214                 return(FALSE);
215         }
216 
217     if(pgDataLogger->Variables[varindex].HasBeenWritten == 1) pgDataLogger->
      Variables[varindex].HasBeenWritten = 2; // Second write
218     if(pgDataLogger->Variables[varindex].HasBeenWritten == 0) pgDataLogger->
      Variables[varindex].HasBeenWritten = 1; // First write (1 data point)
219 
220         /* Insere o conteudo */
221         for(nr=0;nr<pgDataLogger->Variables[varindex].Nr;++nr){
222                 for(nc=0;nc<pgDataLogger->Variables[varindex].Nc;++nc){
223                         FlagQueueFull = gQUEUE_RequestWriteIndex(&pgDataLogger->
      Variables[varindex].CircularQueueControl, &queueindex);
224 
225                         pgDataLogger->Variables[varindex].CircularQueue[queueinde
      x] = varvalue[nr+(nc)*pgDataLogger->Variables[varindex].Nr];
226 
227                         if(!FlagQueueFull){
228                                 /* The queue is full. Test if it is the reading h
      ead associated to matlab data files. */
229                                 if(pgDataLogger->Variables[varindex].
      CircularQueueControl.FlagFull[QUEUE_DESTINATION_FILE]==TRUE){
230                                         /* Empty in matlab data file. */
231                                         gDataLogger_MatfileUpdate(pgDataLogger);
232                                         /* Clear flag: */
233                                         pgDataLogger->Variables[varindex].
      CircularQueueControl.FlagFull[QUEUE_DESTINATION_FILE] = FALSE;
234                                 }
235                         }
236                 }
237         }
238 
239         return(TRUE);
240 }
\end{DoxyCode}




Here is the call graph for this function:



Here is the caller graph for this function:

\hypertarget{gdatalogger_8c_a555a2628f1bfa33692e5f51961d287a5}{
\index{gdatalogger.c@{gdatalogger.c}!gDataLogger\_\-IPC\_\-RetrieveVariable@{gDataLogger\_\-IPC\_\-RetrieveVariable}}
\index{gDataLogger\_\-IPC\_\-RetrieveVariable@{gDataLogger\_\-IPC\_\-RetrieveVariable}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{gDataLogger\_\-IPC\_\-RetrieveVariable}]{\setlength{\rightskip}{0pt plus 5cm}int gDataLogger\_\-IPC\_\-RetrieveVariable (char $\ast$ {\em varname}, \/  char $\ast$ {\em varunit}, \/  double $\ast$ {\em pbuffer}, \/  int $\ast$ {\em bufferlen})}}
\label{gdatalogger_8c_a555a2628f1bfa33692e5f51961d287a5}


Definition at line 319 of file gdatalogger.c.



References GDATALOGGERIPC\_\-SHM::Flag, GDATALOGGER\_\-IPC\_\-FLAGDATAAVAILABLE, GDATALOGGER\_\-IPC\_\-FLAGIDDLE, GDATALOGGER\_\-IPC\_\-FLAGNOTEXIST, GDATALOGGER\_\-IPC\_\-FLAGREQUESTDATA, GDATALOGGER\_\-IPC\_\-FLAGTIMEOUT, GDATALOGGERIPC\_\-SHM::QueueData, GDATALOGGERIPC\_\-SHM::QueueSize, GDATALOGGERIPC\_\-SHM::VariableName, and GDATALOGGERIPC\_\-SHM::VariableUnit.




\begin{DoxyCode}
320 {
321         int counter;
322         
323         sprintf(pgDataLoggerIPC_SHM->VariableName, "%s", varname);
324         pgDataLoggerIPC_SHM->Flag = GDATALOGGER_IPC_FLAGREQUESTDATA;
325         
326 /*      printf("\ngDataLogger_IPC_RetrieveVariable: solicitação feita pela variav
      el %s",varname); */
327 
328         counter = 0;
329         while(pgDataLoggerIPC_SHM->Flag == GDATALOGGER_IPC_FLAGREQUESTDATA){
330                 usleep(10000);
331                 if(++counter > 100){
332                         *bufferlen = 0;
333                         pgDataLoggerIPC_SHM->Flag = GDATALOGGER_IPC_FLAGIDDLE;
334                         /* printf("\ngDataLogger_IPC_RetrieveVariable: solicitaçã
      o não atendida"); */
335                         return GDATALOGGER_IPC_FLAGTIMEOUT;
336                 }
337         }
338         
339         if(pgDataLoggerIPC_SHM->Flag==GDATALOGGER_IPC_FLAGDATAAVAILABLE){
340                 memcpy(pbuffer,pgDataLoggerIPC_SHM->QueueData, 
      pgDataLoggerIPC_SHM->QueueSize * sizeof(double));
341                 sprintf(varunit, "%s", pgDataLoggerIPC_SHM->VariableUnit);
342                 *bufferlen = pgDataLoggerIPC_SHM->QueueSize;
343                 pgDataLoggerIPC_SHM->Flag = GDATALOGGER_IPC_FLAGIDDLE;
344                 return GDATALOGGER_IPC_FLAGDATAAVAILABLE;
345         }
346 
347         if(pgDataLoggerIPC_SHM->Flag==GDATALOGGER_IPC_FLAGNOTEXIST){
348                 *bufferlen = 0;
349                 pgDataLoggerIPC_SHM->Flag = GDATALOGGER_IPC_FLAGIDDLE;
350                 return GDATALOGGER_IPC_FLAGNOTEXIST;
351         }
352         
353         *bufferlen = 0;
354         pgDataLoggerIPC_SHM->Flag = GDATALOGGER_IPC_FLAGIDDLE;
355         return GDATALOGGER_IPC_FLAGIDDLE;
356 }
\end{DoxyCode}


\hypertarget{gdatalogger_8c_afa42a993493cf98d32da11e4279816f7}{
\index{gdatalogger.c@{gdatalogger.c}!gDataLogger\_\-IPCUpdate@{gDataLogger\_\-IPCUpdate}}
\index{gDataLogger\_\-IPCUpdate@{gDataLogger\_\-IPCUpdate}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{gDataLogger\_\-IPCUpdate}]{\setlength{\rightskip}{0pt plus 5cm}int gDataLogger\_\-IPCUpdate ({\bf PGDATALOGGER} {\em pgDataLogger})}}
\label{gdatalogger_8c_afa42a993493cf98d32da11e4279816f7}


Definition at line 274 of file gdatalogger.c.



References GDATALOGGERVARIABLE::CircularQueue, GDATALOGGERVARIABLE::CircularQueueControl, FALSE, GDATALOGGERIPC\_\-SHM::Flag, GDATALOGGER\_\-IPC\_\-FLAGDATAAVAILABLE, GDATALOGGER\_\-IPC\_\-FLAGNOTEXIST, GDATALOGGER\_\-IPC\_\-FLAGREQUESTDATA, gDataLoggerIPC\_\-SHM\_\-flagmodeserver, gQUEUE\_\-GetNumberOfUnreadData(), gQUEUE\_\-RequestReadIndex(), GDATALOGGER::m\_\-NumberOfVariables, QUEUE\_\-DESTINATION\_\-IPC, GDATALOGGERIPC\_\-SHM::QueueData, GDATALOGGERIPC\_\-SHM::QueueSize, TRUE, GDATALOGGERVARIABLE::VariableName, GDATALOGGERIPC\_\-SHM::VariableName, GDATALOGGER::Variables, GDATALOGGERVARIABLE::VariableUnit, and GDATALOGGERIPC\_\-SHM::VariableUnit.



Referenced by datalogger\_\-update\_\-IPC().




\begin{DoxyCode}
275 {
276         int QueueIndex,nvar,n,i;
277 
278         /********** IPC **********/
279         if(gDataLoggerIPC_SHM_flagmodeserver==0){
280                 return FALSE;
281         }
282         
283         if(pgDataLoggerIPC_SHM->Flag == GDATALOGGER_IPC_FLAGREQUESTDATA){
284                 
285                 /* Procura pela variavel */
286                 nvar = -1;
287                 for(n=0;n<pgDataLogger->m_NumberOfVariables;++n){
288                         if(strcmp(pgDataLoggerIPC_SHM->VariableName,pgDataLogger-
      >Variables[n].VariableName)==0){
289                                 nvar = n;
290                                 break;
291                         }
292                 }
293                 if(nvar<0){
294                         pgDataLoggerIPC_SHM->Flag = GDATALOGGER_IPC_FLAGNOTEXIST;
      
295                         return FALSE; 
296                 }
297 
298                 /* Metodo otimizado, que salva em uma variavel MATLAB todas as ul
      timas leituras. */
299                 if(!gQUEUE_GetNumberOfUnreadData(&pgDataLogger->Variables[nvar].
      CircularQueueControl, QUEUE_DESTINATION_IPC, &pgDataLoggerIPC_SHM->QueueSize)){
300                         pgDataLoggerIPC_SHM->QueueSize = 0;
301                 }
302                 if(pgDataLoggerIPC_SHM->QueueSize>0){ /* Existem dados a serem sa
      lvos. */
303                         for(i=0;i<pgDataLoggerIPC_SHM->QueueSize;++i){
304                                 gQUEUE_RequestReadIndex(&pgDataLogger->Variables[
      nvar].CircularQueueControl, QUEUE_DESTINATION_IPC, &QueueIndex);
305                                 pgDataLoggerIPC_SHM->QueueData[i] = pgDataLogger-
      >Variables[nvar].CircularQueue[QueueIndex];
306                         }
307                 }
308                 
309                 sprintf(pgDataLoggerIPC_SHM->VariableUnit, "%s", pgDataLogger->
      Variables[nvar].VariableUnit);
310                 pgDataLoggerIPC_SHM->Flag = GDATALOGGER_IPC_FLAGDATAAVAILABLE;
311         }
312 
313         return(TRUE);
314 }
\end{DoxyCode}




Here is the call graph for this function:



Here is the caller graph for this function:

\hypertarget{gdatalogger_8c_a05dc8ce832b941280d7de26057992640}{
\index{gdatalogger.c@{gdatalogger.c}!gDataLogger\_\-MatfileUpdate@{gDataLogger\_\-MatfileUpdate}}
\index{gDataLogger\_\-MatfileUpdate@{gDataLogger\_\-MatfileUpdate}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{gDataLogger\_\-MatfileUpdate}]{\setlength{\rightskip}{0pt plus 5cm}int gDataLogger\_\-MatfileUpdate ({\bf PGDATALOGGER} {\em pgDataLogger})}}
\label{gdatalogger_8c_a05dc8ce832b941280d7de26057992640}


Definition at line 245 of file gdatalogger.c.



References GDATALOGGERVARIABLE::CircularQueue, GDATALOGGERVARIABLE::CircularQueueControl, FALSE, gMATLABDataFile\_\-SaveVector(), GDATALOGGER::GMatlabDataFileConfig, GDATALOGGERVARIABLE::GMatlabDataFileIndex, gQUEUE\_\-GetNumberOfUnreadData(), gQUEUE\_\-RequestReadIndex(), GDATALOGGER::m\_\-NumberOfVariables, QUEUE\_\-DESTINATION\_\-FILE, TRUE, GDATALOGGERVARIABLE::VariableName, and GDATALOGGER::Variables.



Referenced by datalogger\_\-close(), datalogger\_\-write\_\-file(), gDataLogger\_\-Close(), and gDataLogger\_\-InsertVariable().




\begin{DoxyCode}
246 {
247         int QueueIndex,nvar,datasize,i;
248         double *v;
249         char matvarname[70];
250 
251         /********** MATFILE **********/
252         /* Esvaziar queues de todas as variaveis que vao para o arquivo: */
253         for(nvar=0;nvar<pgDataLogger->m_NumberOfVariables;++nvar){
254                 /* Metodo otimizado, que salva em uma variavel MATLAB todas as ul
      timas leituras. */
255                 if(!gQUEUE_GetNumberOfUnreadData(&pgDataLogger->Variables[nvar].
      CircularQueueControl, QUEUE_DESTINATION_FILE, &datasize)){
256                         return(FALSE);
257                 }
258                 if(datasize>0){ /* Existem dados a serem salvos. */
259                         v = (double *) malloc(datasize * sizeof(double));
260                         for(i=0;i<datasize;++i){
261                                 gQUEUE_RequestReadIndex(&pgDataLogger->Variables[
      nvar].CircularQueueControl, QUEUE_DESTINATION_FILE, &QueueIndex);
262                                 v[i] = pgDataLogger->Variables[nvar].
      CircularQueue[QueueIndex];
263                         }
264                         sprintf(matvarname,"%s_%li_%li",pgDataLogger->Variables[n
      var].VariableName,pgDataLogger->Variables[nvar].GMatlabDataFileIndex,pgDataLogger
      ->Variables[nvar].GMatlabDataFileIndex+datasize-1);
265                         gMATLABDataFile_SaveVector(&pgDataLogger->
      GMatlabDataFileConfig, matvarname, v, datasize);
266                         free(v);
267                         pgDataLogger->Variables[nvar].GMatlabDataFileIndex += dat
      asize;
268                 }
269         }
270 
271         return(TRUE);
272 }
\end{DoxyCode}




Here is the call graph for this function:



Here is the caller graph for this function:



\subsection{Variable Documentation}
\hypertarget{gdatalogger_8c_a0400c04ba687b9806fc9543f817388d0}{
\index{gdatalogger.c@{gdatalogger.c}!gDataLoggerIPC\_\-SHM\_\-fd@{gDataLoggerIPC\_\-SHM\_\-fd}}
\index{gDataLoggerIPC\_\-SHM\_\-fd@{gDataLoggerIPC\_\-SHM\_\-fd}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{gDataLoggerIPC\_\-SHM\_\-fd}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf gDataLoggerIPC\_\-SHM\_\-fd} = 0\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{gdatalogger_8c_a0400c04ba687b9806fc9543f817388d0}


Definition at line 36 of file gdatalogger.c.



Referenced by gDataLogger\_\-Close(), and gDataLogger\_\-Init().

\hypertarget{gdatalogger_8c_ab05e4213b873bbf0185738b7fd8a6e4a}{
\index{gdatalogger.c@{gdatalogger.c}!gDataLoggerIPC\_\-SHM\_\-flagmodeserver@{gDataLoggerIPC\_\-SHM\_\-flagmodeserver}}
\index{gDataLoggerIPC\_\-SHM\_\-flagmodeserver@{gDataLoggerIPC\_\-SHM\_\-flagmodeserver}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{gDataLoggerIPC\_\-SHM\_\-flagmodeserver}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf gDataLoggerIPC\_\-SHM\_\-flagmodeserver} = 1\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{gdatalogger_8c_ab05e4213b873bbf0185738b7fd8a6e4a}


Definition at line 31 of file gdatalogger.c.



Referenced by gDataLogger\_\-Close(), gDataLogger\_\-Init(), and gDataLogger\_\-IPCUpdate().

\hypertarget{gdatalogger_8c_af7df326df930ef7f72e0a173e443db7e}{
\index{gdatalogger.c@{gdatalogger.c}!pgDataLoggerIPC\_\-SHM@{pgDataLoggerIPC\_\-SHM}}
\index{pgDataLoggerIPC\_\-SHM@{pgDataLoggerIPC\_\-SHM}!gdatalogger.c@{gdatalogger.c}}
\subsubsection[{pgDataLoggerIPC\_\-SHM}]{\setlength{\rightskip}{0pt plus 5cm}{\bf GDATALOGGERIPC\_\-SHM}$\ast$ {\bf pgDataLoggerIPC\_\-SHM} = NULL\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}
\label{gdatalogger_8c_af7df326df930ef7f72e0a173e443db7e}


Definition at line 30 of file gdatalogger.c.

